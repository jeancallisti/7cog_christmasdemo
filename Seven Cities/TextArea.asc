

TEXTAREA txtArea_hasFocus = -1; //the text area that currently has the focus


//utility variables used to manage the focused text areas' cursor blinking
int cursorBlinkTimer = 0;
int CURSOR_BLINK_SPEED=30;
bool cursorVisible; //used for blinking
bool hideCursor; //there can be plenty of reasons why we don't want to show the cursor despite the text area having the focus



struct TextAreaData {
  
  TEXTAREA ID; //a bit redundant to the slot in the array, but it's just anticipating in case the module gets refactored more cleanly
  String Text;
  bool Enabled;
  ListBox *Box;

  Button* bOK; //used by the error message system
  
  int rowHeight;

  int NbLines; //number of lines used by the text once rendered. The value is valid ONLY  after calling WrapLine

  //fields used by the 3 cursors
  int column[3];
  int row[3];
  int position[3];
  int adjust_x[3];
  int adjust_y[3];
  
  bool FullCapacity; //if this is true, it means that the listbox containing the text is full
  bool scrollable; //false until SetScrollbarControls is properly called
  int rowOffset; //how many rows down did the user scroll? Starts at 0 when the listbox is not scrolled at all.
  
  Label* statusLine;
  Button* bCut;
  Button* bCopy;
  Button* bPaste;
  Button* bAbout;

  Label* curs[4]; //0=cursor, 1=marker1, 2=marker2, 3=marker1_backup
  
  String clipBoard; //what has been copied or cut 
  
  Button* bUp;
  Button* bDown;
  Button* bElevator;
  
  AudioClip* warningSound;
  AudioClip* typeSound;
  
  TextArea_CharSet charset;
  bool warnedAboutCharset; //flag to warn the user about missing special characters, but only once
  bool showLineReturn; //if set to true, special char for line return ( '[' ) will be displayed at the end of each line.
  String forbiddenChars; //contains the chars that cannot be typed into the text area
  bool wrapLine;
  
  String errorMessage; //as long as this contains text, one cannot type into the text area
};
TextAreaData txtAreaData[eTextArea_MaxAreas];


//utility struct, to manipulate both targetted cursor row and column at once,
//and to keep them global
struct TextAreaTarget {
  int x[3];
  int y[3];
};
TextAreaTarget ttarget;



bool IsVisible(TEXTAREA ta)
{
  if (txtAreaData[ta].Box == null)
    return false;
    
  return (   
             (txtAreaData[ta].Box.Visible ) 
          && (txtAreaData[ta].Box.OwningGUI.Visible));
}



bool IsVisibleAndEnabled(TEXTAREA ta)
{
  if (txtAreaData[ta].Box == null)
    return false;
    
  return (   (txtAreaData[ta].Enabled) 
          && IsVisible(ta));
}


//returns the absolute value of a number (turns it positive if it's negative)
int abs(int value) { if (value<0) return -value; }
//min returns the smaller of two values. max returns the larger of two values
int min(int v1, int v2) { if (v1<v2) return v1; return v2;}
int max(int v1, int v2) { if (v1<v2) return v2; return v1;}



//removes focus from 'ta'.
//At the moment is rather redundant to 'removeFocus()'
static void TextAreas::RemoveFocus(TEXTAREA ta)
{
  if (txtArea_hasFocus==ta)
  {
    if (txtAreaData[txtArea_hasFocus].bCut != null)
      txtAreaData[txtArea_hasFocus].bCut.Visible=false;
    if (txtAreaData[txtArea_hasFocus].bCopy != null)
      txtAreaData[txtArea_hasFocus].bCopy.Visible=false;
    if (txtAreaData[txtArea_hasFocus].bPaste != null)
      txtAreaData[txtArea_hasFocus].bPaste.Visible=false;
    if (txtAreaData[txtArea_hasFocus].bAbout != null)
      txtAreaData[txtArea_hasFocus].bAbout.Visible=false;
    
    //hide all cursors (cursor+both markers)
    int t=eCursor;
    while (t<eLoopExit) {
      txtAreaData[txtArea_hasFocus].curs[t].Visible = false;
      t++;
    }
    
    if (txtAreaData[txtArea_hasFocus].statusLine != null)
      txtAreaData[txtArea_hasFocus].statusLine.Text = "Click in the text area to start typing.";

    if (txtAreaData[txtArea_hasFocus].bUp != null)
      txtAreaData[txtArea_hasFocus].bUp.Visible=false;
    if (txtAreaData[txtArea_hasFocus].bDown != null)
      txtAreaData[txtArea_hasFocus].bDown.Visible=false;
    if (txtAreaData[txtArea_hasFocus].bElevator != null)
      txtAreaData[txtArea_hasFocus].bElevator.Visible=false;
      
    txtArea_hasFocus=-1;
    
  }
}




//Returns true if the text area is currently displaying an error message
bool IsDisplayingError(TEXTAREA ta) 
{
  if (txtAreaData[ta].errorMessage == null)
    return false;
  if (txtAreaData[ta].errorMessage.Length == 0)
    return false;
    
  return true;
}


void DisplayError(TEXTAREA ta, String msg)
{

  if (IsDisplayingError(ta))  return; //we can display only one error at a time
    
    
  if (txtAreaData[ta].Box == null) return; //basic safety  
  else txtAreaData[ta].Box.Clear();
    
  txtAreaData[ta].errorMessage = msg;
  if (!IsDisplayingError(ta)) return; //this way we implicitly check the validity of the error message
    
  String remainder = msg;
  while (remainder != "")
  {
    int eol = remainder.IndexOf("[");
    if (eol==-1) { eol = remainder.Length; } //not found. We set it at the end to force-finish parsing
      
    String line = remainder.Before(eol); // '[' not included
    remainder = remainder.After(eol+1); // '[' not included
    
    txtAreaData[ta].Box.AddItem(line);
  }

  txtAreaData[ta].Box.SelectedIndex = -1; //we unselect any selected item.
  
  //now we display the OK button
  txtAreaData[ta].bOK.Text = "OK";
  txtAreaData[ta].bOK.Visible = true;
  //we center it and put it at the bottom of the listbox
  txtAreaData[ta].bOK.X = txtAreaData[ta].Box.X + txtAreaData[ta].Box.Width/2 - txtAreaData[ta].bOK.Width/2;
  txtAreaData[ta].bOK.Y = txtAreaData[ta].Box.Y + txtAreaData[ta].Box.Height - txtAreaData[ta].bOK.Height - 3;
  //we make sure it's on top of the listbox
  txtAreaData[ta].bOK.BringToFront();

  //play the 'ding' sound
  if (txtAreaData[ta].warningSound!=null)
    txtAreaData[ta].warningSound.Play(eAudioPriorityVeryLow);   
          
  TextAreas.RemoveFocus(ta); //so that the cursor stops blinking
  
  if (txtAreaData[ta].statusLine!=null)
    txtAreaData[ta].statusLine.Text = "Click on OK to discard this message.";
}



// gets and stores the height (in pixels) of a row in the listbox, based on its current font
// You can choose between two calculation methods (risky and safe)
static int TextAreas::GetRowHeight(TEXTAREA ta, bool riskyMethod)
{
  
  if (txtAreaData[ta].rowHeight>0) //We do it only once
    return txtAreaData[ta].rowHeight;
  
  
  // if we've never done it before : 
  
  //SAFETY
  if (txtAreaData[ta].Box == null)
    return -1;

  //HEIGHT CALCULATION
  if (riskyMethod)  txtAreaData[ta].rowHeight = txtAreaData[ta].Box.GetRowHeight_risky(); //the risky method is mostly obsolete and shouldn't be used, really.
  else              txtAreaData[ta].rowHeight = txtAreaData[ta].Box.GetRowHeight_safe();
    
  return txtAreaData[ta].rowHeight;
  
}



//updates all variables related to cursor's blinking. We have just one pseudo-timer
//for all the cursors (let's keep it simple shall we)
function CursorBlink()
{
  cursorBlinkTimer++;
  if (cursorBlinkTimer >= CURSOR_BLINK_SPEED)
  {
    cursorBlinkTimer=0;
    cursorVisible=!cursorVisible;
  }
  
}

//this is a comfort function, that delays the cursor blinking to make it
//visible after moving the cursor
function SuspendBlinking()
{
  cursorBlinkTimer=0;
  cursorVisible=true;
}




//sets a cursor target. x and y are screen coordinates, but x_target and y_target are coordinates inside the listbox
void SetTargetXY(TEXTAREA ta,  EnumTarget target,  int x,  int y)
{
  ListBox* l = txtAreaData[ta].Box; //for convenience
  ttarget.x[target]=x-(l.X+l.OwningGUI.X);
  ttarget.y[target]=y-(l.Y+l.OwningGUI.Y)+(txtAreaData[ta].rowOffset*TextAreas.GetRowHeight(ta));
}

//Resets the cursor target
void SetNoTarget(EnumTarget target)
{
  ttarget.x[target] = -1;
  ttarget.y[target] = -1;  
}

//Returns true if there is a cursor target set
bool TargetIsSet(EnumTarget target)
{
   return (ttarget.x[target]!=-1 && ttarget.y[target]!=-1);
}



//removes all the text, and updates all the related variables, in the given text area
function DeleteAllText(int tarea)
{
  txtAreaData[tarea].Text = "";
  int c=eCursor;
  while (c<eLoopExit) {
    txtAreaData[tarea].position[c]=0;
    txtAreaData[tarea].column[c]=0;
    txtAreaData[tarea].row[c]=0;
    c++;
  }
  txtAreaData[tarea].Box.Clear();
  txtAreaData[tarea].Box.AddItem("");
  //SetTargetColRow(0, 0);
}


void RenderScrollBar(TEXTAREA ta)
{
  if (txtAreaData[ta].scrollable) { 
    int elevatorSize = txtAreaData[ta].bDown.Y - (txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height);
    txtAreaData[ta].bElevator.Height = elevatorSize * txtAreaData[ta].Box.GetMaxRows()/txtAreaData[ta].NbLines;
    
    //we set some boundaries, so that it's not toos mall or too big
    if (txtAreaData[ta].bElevator.Height > elevatorSize)
      txtAreaData[ta].bElevator.Height = elevatorSize;
    if (txtAreaData[ta].bElevator.Height < 5)
      txtAreaData[ta].bElevator.Height = 5;
    
    //initial position (at the very top)
    txtAreaData[ta].bElevator.Y = txtAreaData[ta].bUp.Y+txtAreaData[ta].bUp.Height; //initial position
    //Adjusted position (taking scrolling into account)  
    txtAreaData[ta].bElevator.Y +=  ((elevatorSize) * txtAreaData[ta].rowOffset)/txtAreaData[ta].NbLines;
    
    //we set some boundaries again
    if (txtAreaData[ta].bElevator.Y > txtAreaData[ta].bDown.Y - txtAreaData[ta].bElevator.Height)
      txtAreaData[ta].bElevator.Y = txtAreaData[ta].bDown.Y - txtAreaData[ta].bElevator.Height;
    if (txtAreaData[ta].bElevator.Y < txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height)
      txtAreaData[ta].bElevator.Y = txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height;
  }
  
}


//If the 'elevator' control is being dragged:
//1. calculates the visual position of the object from the mouse position
//2. calculates the row offset from the visual position
//3. renders the text area from the row offset
void UpdateScrollbar_FromMousePosition(TEXTAREA ta)
{
  if (txtAreaData[ta].scrollable) { 
  
    //how much did the mouse move vertically since last game cycle?
    int ofsy = mState.offsetSinceLastCycle_y;
    
    //Label2.Text = String.Format("%d", ofsy); //DEBUG
    
    //move elevator accordingly
    txtAreaData[ta].bElevator.Y+=ofsy;
    
    
    //make sure it didn't make the elevator pop out of vertical boundaries
    if (txtAreaData[ta].bElevator.Y > txtAreaData[ta].bDown.Y - txtAreaData[ta].bElevator.Height)
      txtAreaData[ta].bElevator.Y = txtAreaData[ta].bDown.Y - txtAreaData[ta].bElevator.Height;
    if (txtAreaData[ta].bElevator.Y < txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height)
      txtAreaData[ta].bElevator.Y = txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height;
    
    

    //how far down is the elevator scrolled?
    int graphical_scrolling = txtAreaData[ta].bElevator.Y - (txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height);
    
    //how much total space is there between "up" and "down" (minus elevator height)
    int elevatorSize = txtAreaData[ta].bDown.Y - (txtAreaData[ta].bUp.Y + txtAreaData[ta].bUp.Height) - txtAreaData[ta].bElevator.Height;
    
    //transform it into rows space
    if (elevatorSize ==0) //Safety
      txtAreaData[ta].rowOffset = 0;
    else
      txtAreaData[ta].rowOffset = (graphical_scrolling*(txtAreaData[ta].NbLines- txtAreaData[ta].Box.GetMaxRows()))/elevatorSize;
    
    //check boundaries
    if (txtAreaData[ta].rowOffset<0)
      txtAreaData[ta].rowOffset=0;
    if (txtAreaData[ta].rowOffset>txtAreaData[ta].NbLines- txtAreaData[ta].Box.GetMaxRows())
      txtAreaData[ta].rowOffset=txtAreaData[ta].NbLines- txtAreaData[ta].Box.GetMaxRows();    
  
  }
}

void AdjustCursorPosition(TEXTAREA tarea)
{
  int leftPos = min(txtAreaData[tarea].position[eMarker1],txtAreaData[tarea].position[eMarker2] );
  
  if (leftPos == txtAreaData[tarea].position[eMarker1]) { //the leftmost cursor matches Marker1
    txtAreaData[tarea].curs[eMarker1].X += txtAreaData[tarea].adjust_x[eMarker1];
    txtAreaData[tarea].curs[eMarker1].Y += txtAreaData[tarea].adjust_y[eMarker1];
  } else { //the leftmost cursor matches Marker2
    txtAreaData[tarea].curs[eMarker1].X += txtAreaData[tarea].adjust_x[eMarker2];
    txtAreaData[tarea].curs[eMarker1].Y += txtAreaData[tarea].adjust_y[eMarker2];
  }
  txtAreaData[tarea].curs[eCursor].X += txtAreaData[tarea].adjust_x[eCursor];
  txtAreaData[tarea].curs[eCursor].Y += txtAreaData[tarea].adjust_y[eCursor];
}

bool test=false;
#define IFTEST if (test) 

//wraps the text into the tex area's listbox, BUT updating the scrollbar is optional
//(for the case where it's actually the scrollbar's movements that drive the rendering)
void WrapLine2(int tarea,  bool updateScrollbar)
{
  
  if (tarea <0) return;  //safety (when no textarea has the focus, 'tarea' might be -1)
  if (!IsVisible(tarea)) return;  //we don't render invisible text areas
  if (IsDisplayingError(tarea)) return; //we don't render text areas that are displaying an error message    
  ListBox* lstBox = txtAreaData[tarea].Box; //just for convenience
  if (lstBox == null) {
     Display("TextArea: WrapLine : ERROR: listbox cannot be null");
     return;
  }

  int MAXWIDTH = lstBox.Width - 5;
  
  //that will be the pixel position of the 'cursor' sprite. We will update it as long as we don't meet the cursor's targetted position (that's what 'met' is for).
  int x[3]; int y[3]; //for convenience
  int x_in_word[3]; int column_in_word[3]; //for convenience
  bool met[3]; //useful only if the target has been set. This flag tells us to stop looking for hte cursor's targetted position
  Label* curs[3]; //for convenience
    
  int rowHeight = TextAreas.GetRowHeight(tarea, false); //for convenience
  bool wrapLine = txtAreaData[tarea].wrapLine; //for convenience
  
  //some initialization and safety check for our 3 cursors
  int t=eCursor;
  while (t<eLoopExit) {
    curs[t] =   txtAreaData[tarea].curs[t]; //for convenience
    if (TargetIsSet(t)) {
       if (ttarget.x[t] <0) ttarget.x[t] = 0; //just some safety
       if (ttarget.y[t] <0) ttarget.y[t] = 0; //just some safety
       txtAreaData[tarea].position[t]=0;
    }

    //at first, we can't tell the position of the cursor. All we know is 'position' (or ttarget.xy_target)
    //Therefore we set the variables to 0
    txtAreaData[tarea].row[t]=0;
    txtAreaData[tarea].column[t]=0;   
    x[t]=0;
    y[t]=0;

    x_in_word[t]=0;
    column_in_word[t]=0;
    
    t++;
  }
  
  
  txtAreaData[tarea].NbLines=0;   //this will switch to 1 as soon as we start rendering the first line
  txtAreaData[tarea].FullCapacity = false; //a flag we set if the text area may not be scrolled and we've exceeded the max number of lines
  
  // SAFETY CHECK #1 : text length
  if (txtAreaData[tarea].Text == "" || txtAreaData[tarea].Text == null) {
    DeleteAllText(tarea);
  }
  
  // SAFETY CHECK #2 : we always end the text with a line break
  if (!txtAreaData[tarea].Text.EndsWith("["))
    txtAreaData[tarea].Text = txtAreaData[tarea].Text.Append("[");
    

  lstBox.Clear(); //erase all entries in the listbox
  TinyParser.StartParsing(txtAreaData[tarea].Text); //Reset our personal shitty parser tool
  
  bool dumpCursor=false;
  bool storeSpaces=false;
  bool eof=false;
  bool eol=false;
  String word=""; String word_with_c; String line=""; int wordWidth=0;
  //bool dumpWord=false;
  

  char c=TinyParser.GetNextChar();
  
  
  /*
  while (!eof && !txtAreaData[tarea].FullCapacity) //iterate on every paragraph
  {
    String line; //String line_with_word;
    word=""; word_with_c="";
    eol = false;
    dumpWord=false;
  */



    while (!eof /*&& !eol*/ && !txtAreaData[tarea].FullCapacity) { //iterate on every line


      txtAreaData[tarea].NbLines++; //BOOM. we start rendering a line. Therefore, it exists
          
      //line=word; //in case we still have a word pending from previous line
      line=""; 
      int lineWidth=GetTextWidth(line, lstBox.Font);

      IFTEST Display("Starting line. word='%s', x_in_word='%d', column_in_word='%d'", word,  x_in_word[eCursor], column_in_word[eCursor]);


      //dumpCursor=false; //Reset
      storeSpaces=false; //Reset
      //word="";
      //wordWidth=0;
      //word_with_c=word.AppendChar(c);
      int wordWidth_with_c;
      //int wordWidth_with_c=/*lineWidth+*/GetTextWidth(word_with_c, lstBox.Font);
      
      bool wordFits        = true;
      bool wordFits_with_c = false;
      
      bool longWord=false; //set to true if this single word is too long to fit into a line.
      
      //while (wordFits && !eof && !eol && !txtAreaData[tarea].FullCapacity) {    //iterate on every character of the line
      bool dumpLine = false;
      bool dumpWord=false;
      
      while (!dumpLine)     //iterate on every character of the line
      {
        //Display(String.Format("c='%c'",c)); //DEBUG
      
         
        if (TinyParser.EOF() || TinyParser.NewLine()) { //not necessarily exclusive from the other conditions below

          dumpWord=true;
          dumpLine=true;
          
          word_with_c       =word; //we don't add the new character
          wordWidth_with_c  =GetTextWidth(word_with_c, lstBox.Font);
          wordFits_with_c   = true;
          


          //Display(String.Format("EOF or EOL. word_with_c='%s'",word_with_c)); //DEBUG


          if (TinyParser.EOF()) {
            eof=true;
          }
          if (TinyParser.NewLine()) {
            eol=true;
            
            if (txtAreaData[tarea].showLineReturn)
              word=word.AppendChar('[');  //for debug. We do this AFTER updating lineWidth
          }
        }
        else //not a new line, not end of file
        {

          
          word_with_c       =word.AppendChar(c);
          wordWidth_with_c  =GetTextWidth(word_with_c, lstBox.Font);       
          wordFits_with_c   = (lineWidth+wordWidth_with_c <= MAXWIDTH);

          
          //this first part of the computation is meant to adjust
          //some flags for special situations such as 'storeSpaces',
          //'longWord', etc. that will have an impact on the cursors
          //movement just afterwards.

          if (!wordFits_with_c) {
            
            //Display(String.Format("Does not fit. word_with_c='%s'",word_with_c)); //DEBUG
            
            
            if (!wrapLine)  //The word doesn't fit and we don't wrap
            {
              dumpWord=true;
              dumpLine = true; //if we don't wrap, then we dump the line no matter what
            }
            else //if (wrapLine) 
            {
              if (c==' ') { //the word doesn't fit but it's followed by spaces so we consider it fits
                  dumpWord=true;
                  storeSpaces=true;
                  wordFits_with_c=true; //we trigger that back to force-fit additional spaces
              } else {
                if (storeSpaces) { //we were storing spaces and we met a regular character. That's the end of storeSpaces
                  dumpWord=false;
                  dumpLine=true;
                  //WARNING: if we reach this point, 'c' breaks the loop but must still be processed
                } else { // if (!storeSpaces)
                  if (wordWidth_with_c >= MAXWIDTH) { //the word doesn't fit but it's too long for one line anyway
                    //longWord=true;
                    dumpWord=true;
                    dumpLine=true;
                  }
                  else //the word doesn't fit, we encountered a regular character, and we're not storing spaces. 
                  {
                    dumpWord=false;
                    dumpLine=true;                   
                  }
                }
              }
            }
          } else { //wordFits_with_c
            if (c==' ') { //time to dump the word
              dumpWord=true;
            }
          }

          t=eCursor;
          while (t<eLoopExit) {
            
              if (!TargetIsSet(t))   //we are NOT trying to position the cursor based on its (x,y) position.
              {                     //we are trying to place it based on its character index in the text (cursorPos)
                                    
                if (TinyParser.Start()<=txtAreaData[tarea].position[t]) {
                  
                  //if (t==eCursor)
                  //  Display("c='%c', column_in_word='%d'",c, column_in_word[0]);
                    
                  txtAreaData[tarea].column[t]++;
                  column_in_word[t]++;  //TEST
                  //if (!longWord)
                  if (!storeSpaces) {
                    x[t]=lineWidth+wordWidth_with_c;
                    x_in_word[t] = wordWidth_with_c; //TEST                    
                  }
                  //else
                  //  x[t]=MAXWIDTH; //the word is too long. We stop the cursor on the right-hand-side of the listbox even though we keep increasing all other variables (column, position etc.)
                  
                  //if we are precisely on the cursor
                  if (TinyParser.Start()==txtAreaData[tarea].position[t]) {
                    dumpCursor=true;
                  }
                }   
              } 
              else                  //We ARE trying to position the cursor based on its targetted (x,y) position.
              { 
                if (y[t]<=ttarget.y[t] && !met[t]) {
                    if (y[t]+rowHeight >= ttarget.y[t]) { //We are on the LAST line before y[t] is beyond the target
                      //int delta = lineWidth-prevLineWidth;
                      //int delta = wordWidth_with_c-wordWidth;
                      if (lineWidth+wordWidth_with_c<=ttarget.x[t]) {
                        if (!wrapLine || !storeSpaces) { //we don't wrap lines, OR we do but we're currently not storing spaces at the end of a word
                          if (!storeSpaces) {
                              x[t] = lineWidth+wordWidth_with_c;    

                          }
                          txtAreaData[tarea].column[t]++;  
                          txtAreaData[tarea].position[t]=TinyParser.Start();
                        }  
                      } else {
                        met[t] = true;
                      }
                    } else { //any other line before the target
                      //Do nothing
                    }
                } else { //y[t] is beyond the target
                  met[t]=true;
                }
              }
              
              t++;
              
              
          } //while (t<eLoopExit)
        
        } //if ( newline or eof) else ...

        
        if (dumpWord) { //we'll add the word to the line, and keep reading characters
              
          line=line.Append(word_with_c);
          lineWidth=lineWidth+wordWidth_with_c;                

          //Display(String.Format("Dumpword: word_with_c='%s' line='%s'",word_with_c, line)); //DEBUG  
          IFTEST Display(String.Format("Dumpword: word_with_c='%s'",word_with_c)); //DEBUG  

          //RESET
          dumpCursor=false; //Reset
          dumpWord=false; //reset
          word="";
          wordWidth=0;
          
          t=eCursor;
          while (t<eLoopExit) {
            x_in_word[t]=0;
            column_in_word[t]=0;            
            t++;
          }
          
        } //if (dumpWord)
        else 
        {
          word=word_with_c;
          wordFits=wordFits_with_c;
        }
        
        if (!dumpLine) //if we're about to break the loop we don't want to consume the char
                       //because we want to be sure of the last known character position before the end of line
          c=TinyParser.GetNextChar();


      }  //while (!dumpLine)
      
      
      //
      // ========
      //
      // We reach this point because we encountered an end of 
      // line ( '[' ) or the line was too long and needs to be wrapped
      

      //DEBUG
      String reason="";
      if (txtAreaData[tarea].FullCapacity) reason="full capacity";
      else if (!wordFits) reason="!wordFits";
      else if (eol) reason="eol";
      else if (eof) reason="eof";
      //Display(String.Format("Loop broken because of %s: word='%s', line='%s'",reason, word, line)); //DEBUG  
      IFTEST Display("loop broken: word='%s', column_in_word[0]='%d'",word, column_in_word[eCursor]); //DEBUG  
      //~~DEBUG
      
      
      
      if (!txtAreaData[tarea].scrollable && txtAreaData[tarea].NbLines>=lstBox.GetMaxRows()+1) 
      {   
         txtAreaData[tarea].FullCapacity = true;
      }
      else if (!txtAreaData[tarea].FullCapacity)
      {
        t = eCursor;
        while (t<eLoopExit) 
        {
          
            if (!TargetIsSet(t)) { //we are NOT trying to position the cursor based on its (x,y) position.
                                  //we are trying to place it based on its character index in the text (cursorPos)
              
              if (      TinyParser.Start()<=txtAreaData[tarea].position[t] ) //regular case: new line
              { 
                    txtAreaData[tarea].column[t]=0;             
                    txtAreaData[tarea].row[t]++;
                    
                    x[t]=0;
                    y[t]=txtAreaData[tarea].row[t]*rowHeight;

              }
              else if (!wordFits && /*column_in_word[t]<=word.Length*/ dumpCursor) //special case: the cursor was somewhere inside the last word from previous line, which got wrapped
              {
                
                    Display("word='%s', length='%d', column_in_word[%d]='%d', x_in_word[%d]='%d'", word, word.Length, t, column_in_word[t], t, x_in_word[t]);
                    txtAreaData[tarea].column[t]=column_in_word[t];             
                    txtAreaData[tarea].row[t]++;
                    
                    x[t]=x_in_word[t];
                    y[t]=txtAreaData[tarea].row[t]*rowHeight;   
                    dumpCursor=false;
              }
              
              
            } else { //We ARE trying to position the cursor based on its (x,y) position.
                //if (y[t]<=ttarget.y[t]) {
                if (y[t] + rowHeight <= ttarget.y[t]  
                    && !met[t] ) 
                {

                      txtAreaData[tarea].column[t]=0;             
                      txtAreaData[tarea].row[t]++;
                  

                      if (wrapLine) 
                      {
                        if (wordFits) //we're in the regular case. New line = bring the cursor to the left
                        { 
                          x[t] = 0;
                          y[t]+=rowHeight;      
                        }
                        else //we're in the case when the word was too long to fit on the previous line.
                             //the cursor must stay at the end of the previous line
                        {
                          x[t] = lineWidth;
                          y[t] +=rowHeight; //remains unchanged                        
                        }
                      }
                      else
                      {
                          x[t] = 0;
                          y[t]+=rowHeight;                        
                      }
                      txtAreaData[tarea].position[t]=TinyParser.Start();
                } else {
                  met[t]=true;
                }
            }  //if (!TargetIsSet(eCursor))  
            
            t++;
            
        } //while (t<eLoopExit) 

        if (!txtAreaData[tarea].scrollable) //if not scrollable, we add the line without questions
          lstBox.AddItem(line);        
        else { //if scrollable, we make sure the line is within the boundaries currently displayed
          if (   txtAreaData[tarea].NbLines-1 >= txtAreaData[tarea].rowOffset
              && txtAreaData[tarea].NbLines-1 < txtAreaData[tarea].rowOffset + txtAreaData[tarea].Box.GetMaxRows())
            lstBox.AddItem(line);  
        }

      } // if not full capacity or just about to be
  
      /*
      if (wordFits) { //we read a new char only if we broke the loop because eof or eol. If it was because the line wouldn't fit, we still have a character pending.
        c=TinyParser.GetNextChar();
        //Display(String.Format("c='%c'",c)); //DEBUG
      }
      */
      
      /*
      if (eol) {
        word=""; word_with_c="";
        eol = false;
        dumpWord=false;
      }
      */
      
      c=TinyParser.GetNextChar();


    } // while (!EOF() && !eol) { //process a paragraph
  
  /*
  } //while (!EOF()) 
  */
  
  lstBox.SelectedIndex=-1; //Remove the highlight from the selected listbox row

  t=eCursor;
  while (t<eLoopExit) {
    SetNoTarget(t); //we're not aiming at any new position for the cursor

    //now we transform the coordinates of the cursor from "within listbox" space to "coordinates inside GUI" space
    curs[t].X=lstBox.X+x[t];
    curs[t].Y=lstBox.Y+y[t]-(txtAreaData[tarea].rowOffset*rowHeight)+2;
 
    curs[t].X=lstBox.X+x[t];
    curs[t].Y=lstBox.Y+y[t]-(txtAreaData[tarea].rowOffset*rowHeight)+2;


    t++;
  }

  //finally, we slightly adjust the position
  AdjustCursorPosition(tarea);
    
  //we update the scrollbar position, but only if ordered
  //(that must not be done if the player is actualy moving the scrollbar)
  if (updateScrollbar)
    RenderScrollBar(tarea);
    
  Label2.Text = String.Format("pos=%d",txtAreaData[tarea].position[eCursor]);
}

void WrapLine(int tarea)
{
  WrapLine2(tarea,  true);
}

void RemoveError(TEXTAREA ta)
{
  txtAreaData[ta].bOK.Visible = false;
  txtAreaData[ta].errorMessage = "";
  WrapLine(ta);
  if (txtAreaData[ta].statusLine!=null)
    txtAreaData[ta].statusLine.Text = "Click in the text area to start typing.";
  //TextAreas.RemoveFocus(ta);
}

int TextLength (int tarea) {  return txtAreaData[tarea].Text.Length; }


//removes the character just before the cursor, and updates all the related variables
//IMPORTANT: this does not check for characters with escape chars (e.g. if  the characters
// just before cursor are "\[", it will only delete "["
function RemoveCharBeforeCursor(int tarea)
{
  if (txtAreaData[tarea].position[eCursor]>0)  {
    txtAreaData[tarea].Text = txtAreaData[tarea].Text.RemoveCharAt(txtAreaData[tarea].position[eCursor]-1);
    txtAreaData[tarea].position[eCursor]--;
  }
}


//removes the character at cursor position, and updates all the related variables
//IMPORTANT: this does not check for characters with escape chars (e.g. if  the characters
// at cursor are "\[", it will only delete "\"
function RemoveCharAtCursor(int tarea)
{
  if (txtAreaData[tarea].position[eCursor]<TextLength(tarea)) {
    txtAreaData[tarea].Text = txtAreaData[tarea].Text.RemoveCharAt(txtAreaData[tarea].position[eCursor]);
  }
}

void InsertAtCursor(int tarea,  String s)
{
  String before = txtAreaData[tarea].Text.Before( txtAreaData[tarea].position[eCursor]);
  String after = txtAreaData[tarea].Text.After( txtAreaData[tarea].position[eCursor]);
  before = before.Append(s);
  txtAreaData[tarea].Text = before.Append(after);
  txtAreaData[tarea].position[eCursor]+=s.Length;
}






//returns the character at some relative position from the cursor position.
//Returns eKeyReturn if such character does not exist
char GetChar_FromCursor(int tarea,  int offsetFromCursor) {
  if (  txtAreaData[tarea].position[eCursor]+offsetFromCursor >=0
    && txtAreaData[tarea].position[eCursor]+offsetFromCursor <= txtAreaData[tarea].Text.Length-1)
    return txtAreaData[tarea].Text.Chars[txtAreaData[tarea].position[eCursor]+offsetFromCursor];
  return eKeyReturn; //default: any key that's not usually in a String
}

char LastCharBeforeCursor(int tarea) {          return GetChar_FromCursor(tarea, -1); }
char SecondToLastCharBeforeCursor(int tarea) {  return GetChar_FromCursor(tarea, -2); }
char CharAtCursor(int tarea) {                  return GetChar_FromCursor(tarea, 0);}
char CharAfterCursor(int tarea) {               return GetChar_FromCursor(tarea, 1);}

bool CursorIsAfterLastChar(int tarea) { return (CharAfterCursor(tarea) == eKeyReturn);}





//returns true if keycode is one of the chars in 'characters'
bool IsOneOf(char keycode,  String characters)
{
  return (characters.Contains(String.Format("%c",keycode)) >=0);
}

//takes an accentuated character (e.g. '?') and returns its ascii equivalent (e.g. 'E').
//The result is a CAPITAL letter.
char DealWithWeirdAccentuation(char keycode,  int tarea)
{
    char smallkeycode = LowerCase(keycode);
    if (IsOneOf(smallkeycode,  "???????????????????"))
    { //TODO: this function is a bit sloppy: 
      // - it probably misses many special characters,
      // - and it doesn't handle special CAPITALS very well
      if (txtAreaData[tarea].charset == eTextArea_AngloSaxonOnly) //our text area is set up not to handle special characters
      {
          if (!txtAreaData[tarea].warnedAboutCharset)
          {
            //Display("PLEASE NOTE: the maker of this [game used a font that does not [allow special characters.[[  All the special characters you [type in will be replaced with their [equivalent from the standard [ASCII set.[[  We recommend you contact the [maker of this game and request [from them that they start using [256-characters fonts, that's [more respectful of international [users.[[  You will see this warning only [once.");
            String error = "PLEASE NOTE: the maker of this [game used a font that does not [allow special characters.[[  All the special characters you [type in will be replaced with their [equivalent from the standard [ASCII set.[[  We recommend you contact the [maker of this game and request [from them that they start using [256-characters fonts, that's [more respectful of international [users.[[  You will see this warning only [once.";
            DisplayError(tarea, error);
            txtAreaData[tarea].warnedAboutCharset=true; //we display that warning only once
          }
          
          if (    IsOneOf(smallkeycode,  "?")) //TODO: find out why this specific char doesn't work while the others work
            keycode = 'C';
          else if (  IsOneOf(smallkeycode, "???"))
            keycode = 'A';
          else if (  IsOneOf(smallkeycode, "????"))
            keycode = 'E';
          else if ( IsOneOf(smallkeycode, "???"))
            keycode = 'I';       
          else if ( IsOneOf(smallkeycode, "???"))
            keycode = 'O';
          else if ( IsOneOf(smallkeycode, "?"))
            keycode = 'B';
          else if ( IsOneOf(smallkeycode, "????"))
            keycode = 'U';
          else if ( IsOneOf(smallkeycode, "?"))
            keycode = 'N';
      }
      else if (txtAreaData[tarea].charset == eTextArea_WesternEurope) //our text area IS set up to handle special characters. 
      {
        //TODO: create a function to detect if this character has a glyph
        //in the font (otherwise it will be rendered as a space)
        InsertAtCursor(tarea,  String.Format("%c",keycode));
      }
    }
    return keycode;
}


//if full capacity, restores the text that got saved before modifying the text and rendering it.
//Then, displays error message.
//It works only if 'backupTxt' and 'cursorPosBackup' were properly set beforehand.
void ManageFullCapacity(TEXTAREA ta,  String backupTxt,  int cursorPosBackup)
{
      //rendering this text made it exceed the max number of lines in the text area...
      if (txtAreaData[ta].FullCapacity) {
         //we restore the previous state
         txtAreaData[ta].Text = backupTxt; //we restore the previous text
         txtAreaData[ta].position[eCursor] = cursorPosBackup; //we restore the previous cursor position
         
         //we render it again
         WrapLine(ta);
         
         txtAreaData[ta].warningSound.Play(eAudioPriorityVeryLow);
         //Display("This text area cannot be scrolled up or down.[It is full, you can't add more text.");
         String error = "This text area was not set up[to enable scrolling and it has[reached its maximum number[of lines.[Click on OK to go back to typing.";
         DisplayError(ta,  error);
      }
}



//marker1 is an opening bracket, marker2 is a closing bracket.
//That means they can be displayed in the wrong order if the player started
//highlighting text right-to-left. This function swaps the markers.
void SortMarkers(TEXTAREA ta) {
  GUIControl* leftMarker = txtAreaData[ta].curs[3];
  
  if (txtAreaData[ta].position[eMarker1] <= txtAreaData[ta].position[eMarker2]) {
    //positions are in the expected order...
    if (txtAreaData[ta].curs[eMarker1] == txtAreaData[ta].curs[3]) {//...and graphics not swapped
      //do nothing
    } else { //...but graphics swapped   
      //swap them back!
      txtAreaData[ta].curs[eMarker2] = txtAreaData[ta].curs[eMarker1];
      txtAreaData[ta].curs[eMarker1] = txtAreaData[ta].curs[3];
    }
      
  } else {
    //positions are in the wrong order...
    if (txtAreaData[ta].curs[eMarker2] == txtAreaData[ta].curs[3]) {//...but graphcs already swapped
      //do nothing
    } else { //...but graphics not swapped
      //swap them!
      txtAreaData[ta].curs[eMarker1] = txtAreaData[ta].curs[eMarker2];
      txtAreaData[ta].curs[eMarker2] = txtAreaData[ta].curs[3];
    } 
  }
}


//if the markers are in the same place, display regular cursor.
//Otherwise, hide the regular cursor and show the markers.
//If the markers are in the wrong order, revert them.
void ManageMarkersVisibility(TEXTAREA ta)
{
    if (ta>=0){
      if (txtAreaData[ta].position[eMarker1] == txtAreaData[ta].position[eMarker2])
      {
        //both markers are in the same place... no highlight
        txtAreaData[ta].curs[eMarker1].Visible = false;
        txtAreaData[ta].curs[eMarker2].Visible = false; 
        //note: we don't force the regular cursor to be visible,
        //in case it was hidden for some other reason beforehand
        
      } else {
        txtAreaData[ta].curs[eCursor].Visible = false; //regular cursor is hidden
        //note: we don't force the markers to be visible,
        //in case they were hidden for some other reason beforehand
      }
      
      SortMarkers(ta); //places the selection markers in the right order
    } 
}

//If the cursor is not within visible frame, the row offset is changed to teleport
//to a place where the cursor is visible. 
//You stil need to re-render the text area afterwards, though
void AdjustOffestToCursorPosition(TEXTAREA ta)
{
    if (    txtAreaData[ta].row[eCursor] < txtAreaData[ta].rowOffset
         || txtAreaData[ta].row[eCursor] > txtAreaData[ta].rowOffset+txtAreaData[ta].Box.GetMaxRows()-1 )  //woops, the cursor is outside of the currently rendered text
    { 
      
      if (txtAreaData[ta].row[eCursor] > txtAreaData[ta].rowOffset)
        txtAreaData[ta].rowOffset = txtAreaData[ta].row[eCursor] - (txtAreaData[ta].Box.GetMaxRows()-1); //arbitrary : the cursor is now on the last rendered line of the text area
      else
        txtAreaData[ta].rowOffset = txtAreaData[ta].row[eCursor];//arbitrary : the cursor is now on the first rendered line of the text area
      
    }  
}

void Cut(TEXTAREA ta)
{
  //make sure the markers are in the right order
  int left = min(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
  int right = max(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
  
  //remove the text inbetween them and save it to the clipboard
  String before = txtAreaData[ta].Text.Before(left);
  String after = txtAreaData[ta].Text.After(right);
  txtAreaData[ta].clipBoard = txtAreaData[ta].Text.Substring(left,  right-left);
  //Label2.Text=txtAreaData[ta].clipBoard; //DEBUG
  txtAreaData[ta].Text = before.Append(after);
  
  //Remove the markers
  txtAreaData[ta].position[eCursor] = left;
  txtAreaData[ta].position[eMarker1] = left;
  txtAreaData[ta].position[eMarker2] = left;
  SetNoTarget(eCursor);
  SetNoTarget(eMarker1);
  SetNoTarget(eMarker2);
  
  //make sure the cursor will still be in the visible frame after rendering
  AdjustOffestToCursorPosition(ta);
  
  //render the text area
  WrapLine(ta);
}

void Copy(TEXTAREA ta)
{
  //make sure the markers are in the right order
  int left = min(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
  int right = max(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
  
  //save the text inbetween them to the clipboard
  txtAreaData[ta].clipBoard = txtAreaData[ta].Text.Substring(left,  right-left);
  //Label2.Text=txtAreaData[ta].clipBoard; //DEBUG
}

void Paste(TEXTAREA ta)
{
  //do some backup in case pasting will be prevented by something
  String backupTxt = txtAreaData[ta].Text;
  int backupCursorPos = txtAreaData[ta].position[eCursor];

  //make sure the markers are in the right order
  int left = min(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
  int right = max(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
  
  //remove the text inbetween them
  String before = txtAreaData[ta].Text.Before(left);
  String after = txtAreaData[ta].Text.After(right); 
  //insert the clipboard between them
  txtAreaData[ta].Text = before.Append(txtAreaData[ta].clipBoard);
  txtAreaData[ta].Text = txtAreaData[ta].Text.Append(after);
  
  //Remove the markers
  right = left+txtAreaData[ta].clipBoard.Length;
  txtAreaData[ta].position[eCursor] = right;
  txtAreaData[ta].position[eMarker1] = right;
  txtAreaData[ta].position[eMarker2] = right;
  SetNoTarget(eCursor);
  SetNoTarget(eMarker1);
  SetNoTarget(eMarker2);

  //make sure the cursor will still be in the visible frame after rendering
  AdjustOffestToCursorPosition(ta);
  
  //render the text area
  WrapLine(ta);
  
  //will restore former text and display error if full capacity was reached
  ManageFullCapacity(ta, backupTxt,  backupCursorPos);
  
}






void ScrollUp(TEXTAREA ta)
{
  if (txtAreaData[ta].rowOffset > 0)
    txtAreaData[ta].rowOffset--;
    
  WrapLine(ta);
}



void ScrollDown(TEXTAREA ta)
{

  if (txtAreaData[ta].rowOffset + txtAreaData[ta].Box.GetMaxRows() <= txtAreaData[ta].NbLines)
    txtAreaData[ta].rowOffset++;
  WrapLine(ta);
  
}



  //(optional) Any character included in 'forbiddenChars' cannot be typed into the text
  //           area, and display a warning message for the player.
static void TextAreas::SetForbiddenChars(TEXTAREA ta, String forbiddenChars)
{
    if (forbiddenChars == null) forbiddenChars = "";
    txtAreaData[ta].forbiddenChars = forbiddenChars;
}

function on_key_press(int keycode) {
  
  SetNoTarget(eCursor); //Reset: we're not aiming at any new position for the cursor
  
  SuspendBlinking(); //for user's comfort, we briefly suspend blinking while typing
    
  int ta = 0;
  //while (tarea < nbTextAreas) {
  bool dontAddCharacter = false; //special flag to forbid the character to be added to the text
  if (txtArea_hasFocus>=0)
  {
    ta = txtArea_hasFocus; //for convenience
    if (IsVisibleAndEnabled(ta)) {
      
      if (TextAreas.GetRowHeight(ta) == -1) { //will compute and store it, if not already done
         Display("on_key_press :ERROR: could not compute row height");
         return;
      }      
      
      if (txtAreaData[ta].typeSound!=null)
        txtAreaData[ta].typeSound.Play(eAudioPriorityVeryLow);

      bool showFullCapacityMessage=false;
      
      //we make sure that when the player types, the scrolling automatically teleports to where he's currently typing
      AdjustOffestToCursorPosition(ta);
      
      
      //we want to be able to revert
      String backupTxt = txtAreaData[ta].Text;
      int cursorPosBackup = txtAreaData[ta].position[eCursor];
      
      
      //char smallkeycode = LowerCase(keycode); //we do that to avoid mistake with CAPITAL accentuated letters
      keycode = DealWithWeirdAccentuation(keycode,  ta); //E.g. changes '?' to 'u' depending on the text area's Init settings
      
      if (IsOneOf(keycode, txtAreaData[ta].forbiddenChars)) {
          String error = String.Format("Forbidden character: please[do not type '%c' into this text[area.[[Note: That was set up by the[maker of the game, that's not[a restriction of the module.",keycode);
          DisplayError(ta, error);  
          return;
      }

      //we start off with keys that don't modify the text
      if (keycode==eKeyLeftArrow) { //LEFT
        if (txtAreaData[ta].position[eCursor]>=1)
          txtAreaData[ta].position[eCursor]--;
          
        if (txtAreaData[ta].position[eCursor]>=1)
          if (CharAtCursor(ta) == eKeyOpenBracket 
              && LastCharBeforeCursor(ta) == eKeyBackSlash)
             txtAreaData[ta].position[eCursor]--; //we move left again to skip the backslash
              
      }
      else if (keycode==eKeyRightArrow) { //RIGHT
        if (!CursorIsAfterLastChar(ta))
          txtAreaData[ta].position[eCursor]++;
          
        if (!CursorIsAfterLastChar(ta))
          if (CharAtCursor(ta) == eKeyBackSlash 
              && CharAfterCursor(ta) == eKeyOpenBracket)
             txtAreaData[ta].position[eCursor]++; //we move right again to skip the backslash   
      }
      else if (keycode==eKeyUpArrow) { //UP
        //transform the cursor Label's coordinates back into textarea coordinates
        if (txtAreaData[ta].row[eCursor] > 0) {
          Label* cursor = txtAreaData[ta].curs[eCursor]; //for convenience
          int target_x = cursor.X+cursor.OwningGUI.X;
          int target_y = cursor.Y+cursor.OwningGUI.Y - txtAreaData[ta].rowHeight;
          
          SetTargetXY(ta, eCursor,  target_x, target_y);
        }
      }
      else if (keycode==eKeyDownArrow) { //DOWN
        //transform the cursor Label's coordinates back into textarea coordinates
        
        Label* cursor = txtAreaData[ta].curs[eCursor]; //for convenience
        int target_x = cursor.X+cursor.OwningGUI.X;
        int target_y = cursor.Y+cursor.OwningGUI.Y + txtAreaData[ta].rowHeight;
        
        SetTargetXY(ta, eCursor,  target_x, target_y);
       
      }
      else if (keycode==eKeyCtrlC) { //CTRL+C
        Copy(ta);
      }
      else if (keycode==eKeyCtrlX) { //CTRL+X
        Cut(ta);
      }
      else if (keycode==eKeyCtrlV) { //CTRL+V
        Paste(ta);
      }

      else { //characters that actually MODIFY the text (note: 'cut' and 'paste' have their own way of dealing with that)
            
            bool somethingIsSelected = false;
            
            //if the markers were set, the newly typed text will overwrite what's between them
            if (txtAreaData[ta].position[eMarker1] != txtAreaData[ta].position[eMarker2]) {
              somethingIsSelected = true;
              //we sort out the leftmost and rightmost marker
              int left = min(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
              int right =  max(txtAreaData[ta].position[eMarker1],  txtAreaData[ta].position[eMarker2]);
              
              //we remove the text inbetween
              String before=txtAreaData[ta].Text.Before(left);
              String after=txtAreaData[ta].Text.After(right);
              txtAreaData[ta].Text = before.Append(after);
              
              //we reset the cursor(s)' position to the left-hand-side marker
              txtAreaData[ta].position[eCursor] = left;
              txtAreaData[ta].position[eMarker1] = left;
              txtAreaData[ta].position[eMarker2] = left;
            }
            
            if (keycode == 8) { //BACKSPACE
              if (TextLength(ta) >=2) {
                if (!somethingIsSelected) { //if there's a selection we don't delete more than the selected text
                  //if we detect "\[" : it means the user tried to type '[' into the text area, and we converted it to "\[" in Text. 
                  bool b = (     (LastCharBeforeCursor(ta) == eKeyOpenBracket) 
                              && (SecondToLastCharBeforeCursor(ta) == eKeyBackSlash));
                  
                  RemoveCharBeforeCursor(ta);
                  
                  if (b)
                     RemoveCharBeforeCursor(ta);
                }
              }
              else
              {
               DeleteAllText(ta);     
              }
            }
            
            else if (keycode == eKeyDelete) { //DEL
              if (TextLength(ta) >=2) {
                if (!somethingIsSelected) { //if there's a selection we don't delete more than the selected text
                  //if we detect "\[" : it means the user tried to type '[' into the text area, and we converted it to "\[" in Text. 
                  bool b = (     (CharAtCursor(ta) == eKeyBackSlash) 
                              && (CharAfterCursor(ta) == eKeyOpenBracket));
                  RemoveCharAtCursor(ta);
                  
                  if (b)
                     RemoveCharAtCursor(ta);
                }
              }
              else
              {
               DeleteAllText(ta);     
              }
            
            } 
            else if (keycode == 13) { //RETURN
                InsertAtCursor(ta,  String.Format("%c", eKeyOpenBracket)); // [
            }
                
            else 
            { //characters that strictly ADD data
                      
                if (keycode == 9) { //TAB
                  String tab = "     ";
                  InsertAtCursor(ta,  tab);
                } 
                else if (((keycode >= 32) && (keycode <= 96)) || ((keycode >= 123) && (keycode <= 126)))
                {
                  //LETTERS
                  int key = keycode;
                  if (((key >= 'A') && (key <= 'Z')) && (!IsKeyPressed(403)) && (!IsKeyPressed(404)) && (!System.CapsLock)) 
                    key += 32;
                  if (txtAreaData[ta].Text==null)
                  {
                    DeleteAllText(ta);
                  }
                  
                  if (key == eKeyOpenBracket)  //'['
                  {
                    if (TextLength(ta)>=1)
                    {
                      if (LastCharBeforeCursor(ta) == eKeyBackSlash)
                      {
                        //Display("Forbidden character: please do not type \[ just after \\");
                        String error = "Forbidden character: please do not type \[ just after \\";
                        DisplayError(ta, error);
                  
                        //the reason for this is explained here : http://www.adventuregamestudio.co.uk/wiki/Escaping_characters
                        dontAddCharacter = true;
                      }
                      else
                        InsertAtCursor(ta,  String.Format("%c",eKeyBackSlash)); //we add a backslah to make sure the bracket is rendered "as is"
                    }
                  }
                  
                  if (!dontAddCharacter)
                    InsertAtCursor(ta,  String.Format("%c",key));
                }
              
            }
      } //characters that actually MODIFY the text
      
      WrapLine(ta);
      //if full capacity reached, restore previous version
      ManageFullCapacity(ta,  backupTxt, cursorPosBackup);

      ManageMarkersVisibility(ta);
      
      ClaimEvent();

    }
    //tarea++;
  }
  // 
}

TEXTAREA ListBox_AsTextArea(GUIControl* c)
{
  if (c==null)
    return -1;
    
  ListBox* l = c.AsListBox;
  if (l==null)
    return -1; //it's not a listbox
    
  int i=0;
  while (i<eTextArea_MaxAreas)
  {
    if (txtAreaData[i].Box == l)
      return i;
    i++;
  }
  return -1;
}




static int TextAreas::GetColumn(TEXTAREA ta)
{
  return txtAreaData[ta].column[eCursor];
}
static int TextAreas::GetRow(TEXTAREA ta)
{
  return txtAreaData[ta].row[eCursor];
}

void About(TEXTAREA ta)
{
    //Display("Text Area 0.91[module for AGS by Chris Jones[by Monsieur Ouxx[based on Text Area 0.0.1.1 by monkey_05_06");
    String error = "Text Area 0.92 module by Monsieur Ouxx.[[For AGS by Chris Jones[[Inspired by Text Area 0.0.1.1 by monkey_05_06";
    DisplayError(ta, error);
}


static void TextAreas::Disable(TEXTAREA ta)
{
  txtAreaData[ta].Enabled =false;
}

static void TextAreas::Enable(TEXTAREA ta)
{
  txtAreaData[ta].Enabled =true;  
}

static bool TextAreas::IsEnabled(TEXTAREA ta)
{
  return txtAreaData[ta].Enabled;
}

static void TextAreas::SetFocus(TEXTAREA ta)
{  
  if (!IsVisible(ta)) {
    Display("TextAreas::SetFocus ERROR: cannot give focus to a text area if ListBox is not visible");
    return;
  }
    
  if (!txtAreaData[ta].Enabled) //you cannot give the focus to a disabled text area
    return;
      
  txtArea_hasFocus = txtAreaData[ta].ID;
  
  //txtAreaData[txtArea_hasFocus].Box.OwningGUI.Visible = true;
  
  //if (txtArea_hasFocus>=0)
  //{
    if (txtAreaData[txtArea_hasFocus].bCut != null)
      txtAreaData[txtArea_hasFocus].bCut.Visible=true;
    if (txtAreaData[txtArea_hasFocus].bCopy != null)
      txtAreaData[txtArea_hasFocus].bCopy.Visible=true;
    if (txtAreaData[txtArea_hasFocus].bPaste != null)
      txtAreaData[txtArea_hasFocus].bPaste.Visible=true;
    if (txtAreaData[txtArea_hasFocus].bAbout != null)
      txtAreaData[txtArea_hasFocus].bAbout.Visible=true;

    if (txtAreaData[txtArea_hasFocus].bUp != null)
      txtAreaData[txtArea_hasFocus].bUp.Visible=true;
    if (txtAreaData[txtArea_hasFocus].bDown != null)
      txtAreaData[txtArea_hasFocus].bDown.Visible=true;
    if (txtAreaData[txtArea_hasFocus].bElevator != null)
      txtAreaData[txtArea_hasFocus].bElevator.Visible=true;
      
  //}
  
  WrapLine(txtArea_hasFocus);
  
  
}

//removes focus to any text area that would have the focus right now
function RemoveFocus()
{
  if (txtArea_hasFocus>=0)
    TextAreas.RemoveFocus(txtArea_hasFocus);
}




function repeatedly_execute_always() 
{
    
    CursorBlink(); //update the blinking state (does not reflect on display. See below)
    
    //if the textarea's gui or listbox is not visible 
    //anymore (because of end-user's scripting choices), 
    //then the textarea loses the focus
    //and the related controls get hidden, automatically.
    if (txtArea_hasFocus>=0)
      if (!IsVisible(txtArea_hasFocus))
        RemoveFocus();
    
    if (txtArea_hasFocus>=0  ) {
      int t=eCursor;
      while (t<eLoopExit) {
          //for readability
          int row = txtAreaData[txtArea_hasFocus].row[t]; int col = txtAreaData[txtArea_hasFocus].column[t];
          int rowOffset = txtAreaData[txtArea_hasFocus].rowOffset; int maxRows = txtAreaData[txtArea_hasFocus].Box.GetMaxRows();
          GUIControl* curs = txtAreaData[txtArea_hasFocus].curs[t];
          
          if (row >= rowOffset && row <= rowOffset+maxRows) {
              if (t==eCursor)
                curs.Visible = cursorVisible; //the 'regular' cursor is a special case because it blinks
              else
                curs.Visible = true;
          } else {
            curs.Visible=false;
          }
        
          t++;
      }
    }

    /////// SECTON THAT HANDLES THE CLICKS ////////////
    
    //if (StandaloneClick.ClickDetected(eMouseLeft))
    GUIControl* drop=bState[eMouseLeft].cDrop; 
    GUIControl* drag=bState[eMouseLeft].cDrag; 
    TEXTAREA ta_drop = ListBox_AsTextArea(drop);
    TEXTAREA ta_drag = ListBox_AsTextArea(drag);
    
    if (drop!=null) //a GUIControl was clicked
    {
        if (txtArea_hasFocus>=0){ //if a text area has the focus...
            //...then did we click on one of its controls?
            if (drop == txtAreaData[txtArea_hasFocus].bCut)        Cut(txtArea_hasFocus);
            else if (drop == txtAreaData[txtArea_hasFocus].bCopy)  Copy(txtArea_hasFocus);
            else if (drop == txtAreaData[txtArea_hasFocus].bPaste) Paste(txtArea_hasFocus);   
            else if (drop == txtAreaData[txtArea_hasFocus].bAbout) About(txtArea_hasFocus);      
            else if (drop == txtAreaData[txtArea_hasFocus].Box) { /*do nothing*/ }
            else if (drop == txtAreaData[txtArea_hasFocus].bUp) { ScrollUp(txtArea_hasFocus); }
            else if (drop == txtAreaData[txtArea_hasFocus].bDown) { ScrollDown(txtArea_hasFocus); }
            else if (drop == txtAreaData[txtArea_hasFocus].bElevator) { /* do nothing */ }
            
            //it's none of our cherished buttons and it's not the listbox
            else if (ta_drag<0 && ta_drop<0) //we're not fiddling with the listbox
              RemoveFocus(); // Let's remove the focus
        } 
        
        //is it one of the OK buttons?
        TEXTAREA ta=0;
        while (ta<eTextArea_MaxAreas) {
          if (txtAreaData[ta].bOK == drop) {
              RemoveError(ta);
              ta = eTextArea_MaxAreas; // (force-exit loop)
          }
          ta++;
        }
    } 
    
    
    if (drag!=null) {
      
      if (txtArea_hasFocus>=0){ //if a text area has the focus...
        if (drag == txtAreaData[txtArea_hasFocus].bElevator) { //the user is dragging the scrollbar's elevator
          //int rowOffset_before = txtAreaData[txtArea_hasFocus].rowOffset; //first, we backup the current row offset
          UpdateScrollbar_FromMousePosition(txtArea_hasFocus); //then we let the player move the scrollbar up or down
          WrapLine2(txtArea_hasFocus,  false); //we render (without rendering the scrollbar)
        }
      }
      
      //What follows whether or not a text area has the focus...
      
      //did the player drag our text area's listbox
      if (ta_drag >=0 && !IsDisplayingError(ta_drag)) 
      {
          TextAreas.SetFocus(ta_drag);
          SetTargetXY(ta_drag, eCursor,  mouse.x, mouse.y);     
          SetTargetXY(ta_drag, eMarker1,  bState[eMouseLeft].startDrag_x, bState[eMouseLeft].startDrag_y);   
          SetTargetXY(ta_drag, eMarker2,  mouse.x, mouse.y);   

          WrapLine(txtArea_hasFocus);
      } //if (ta >=0)
    }


    // Despite the script above, we might still not be highlighting
    // anything if both cursors are too close.
    //note: we do that AFTER rendering because WrapLine also has its 'visible/not visible' logic
    ManageMarkersVisibility(txtArea_hasFocus);
    
    
    //there was a click on something else
    if (drag==null && drop==null && bState[eMouseLeft].click) {
        RemoveFocus();
    }
    
    
    
    //////////// SECTION THAT HANDLES THE HOVERING ///////////
    if (txtArea_hasFocus>=0)
    {
      if (txtAreaData[txtArea_hasFocus].statusLine != null) {
        GUIControl* h=StandaloneClick.GetHovered();
        if (h==null || h==txtAreaData[txtArea_hasFocus].Box)  { //hovering nothing or the listbox
          if (txtAreaData[txtArea_hasFocus].statusLine != null)
            txtAreaData[txtArea_hasFocus].statusLine.Text = String.Format("(column %d:line %d)",TextAreas.GetColumn(txtArea_hasFocus)+1,TextAreas.GetRow(txtArea_hasFocus)+1 );
          int a=0;
        } else {//hovering one of the buttons
          if (txtAreaData[txtArea_hasFocus].statusLine != null)
            txtAreaData[txtArea_hasFocus].statusLine.Text = StandaloneClick.GetHoveredText();
        }
      }
    }
}

TEXTAREA findFreeTextArea() {
  int i=0;
  while (i<eTextArea_MaxAreas) {
    if (txtAreaData[i].Box == null)
      return i;
    i++;
  }
  Display("findFreeTextArea : ERROR : no more available text areas. You must increase 'eTextArea_MaxAreas'");
  return -1;
}

static void TextAreas::AdjustCursorPosition(TEXTAREA ta, EnumTarget cursor,  int adjust_x,  int adjust_y)
{
  txtAreaData[ta].adjust_x[cursor] = adjust_x;
  txtAreaData[ta].adjust_y[cursor] = adjust_y; 
}

  
  
static TEXTAREA TextAreas::Init(ListBox* lstBox,  Label* cursor,  Button* bOK,  TextArea_CharSet charset, bool wrapLine, bool showLineReturn)
{
  if (lstBox.Width<20 || lstBox.Height < lstBox.GetRowHeight_safe()) {
      Display(String.Format("ERROR: Text Areas : The listbox cannot be less than 20 px wide and %d high.",lstBox.GetRowHeight_safe()));
      return -1;
  }
  
  TEXTAREA ID = findFreeTextArea();
  
  if (ID>=0){
    txtAreaData[ID].ID = ID;
    
    txtAreaData[ID].Enabled = true;
    txtAreaData[ID].Box = lstBox;
    txtAreaData[ID].bOK = bOK;
    txtAreaData[ID].bOK.Visible = false;
    txtAreaData[ID].errorMessage = "";

    txtAreaData[ID].curs[eCursor] = cursor;
    txtAreaData[ID].curs[eCursor].Visible = false;
    //txtAreaData[ID].curs[eCursor].Width = 3;
    //txtAreaData[ID].curs[eCursor].Height = 10;
    txtAreaData[ID].curs[eCursor].Text = "|";  
    txtAreaData[ID].curs[eCursor].Clickable = false;
    txtAreaData[ID].curs[eCursor].BringToFront(); //to make sure it won't be hidden by the listbox. that would be stupid!
    txtAreaData[ID].adjust_x[eCursor]=0;
    txtAreaData[ID].adjust_y[eCursor]=0;
    
    txtAreaData[ID].charset = charset;
    txtAreaData[ID].showLineReturn = showLineReturn;
    txtAreaData[ID].wrapLine = wrapLine;
    
    txtAreaData[ID].scrollable = false;
    
    txtAreaData[ID].forbiddenChars = "";
    txtAreaData[ID].clipBoard = "";

    DeleteAllText(ID);
    
    txtAreaData[ID].Box.SelectedIndex = -1;
    txtAreaData[ID].Box.Clickable = false;
    
    StandaloneClick.RegisterControl(lstBox, "");

    RemoveFocus();
    SetNoTarget(eCursor);
    SetNoTarget(eMarker1);
    SetNoTarget(eMarker2);
    
    //nbTextAreas++;
  }
  return ID;
}




static int TextAreas::GetCursorPosition(TEXTAREA ta)
{
  return txtAreaData[ta].position[eCursor];
}

static String TextAreas::GetText(TEXTAREA ta)
{
  return txtAreaData[ta].Text;
}



static void TextAreas::SetText(TEXTAREA ta, String txt)
{
  txtAreaData[ta].Text=txt;
  //SetTargetColRow(0, 0);
  //TODO : set proper coordinates
  SetTargetXY(ta, eCursor, 0, 0);
  WrapLine(txtAreaData[ta].ID);
}
  
  
static void TextAreas::SetCopyPasteControls(TEXTAREA ta, Button* _bCut,  Button* _bCopy,  Button* _bPaste,  Label* _marker1,  Label* _marker2)
{
  txtAreaData[ta].bCut = _bCut;
  txtAreaData[ta].bCopy = _bCopy;
  txtAreaData[ta].bPaste = _bPaste;

  int t=eMarker1;
  while (t<eLoopExit) 
  {
    if (t==eMarker1) {
      txtAreaData[ta].curs[t] = _marker1;
      //txtAreaData[ta].curs[t].Text = "\\["; //The text must be '\[' in the label, not '[' otherwise you won't see a thing! ;)
    } else if (t==eMarker2) {
      txtAreaData[ta].curs[t] = _marker2;
      //txtAreaData[ta].curs[t].Text = "]";   
    }
    txtAreaData[ta].curs[t].Visible = false;
    //txtAreaData[ta].curs[t].Width = 3;
    //txtAreaData[ta].curs[t].Height = 10;
    txtAreaData[ta].curs[t].Clickable = false;
    txtAreaData[ta].curs[t].BringToFront(); //to make sure it won't be hidden by the listbox. that would be stupid!

    txtAreaData[ta].adjust_x[t]=0;
    txtAreaData[ta].adjust_y[t]=0;
    
    t++;
  }
  
  //we also make a backup of marker1, to remember which is which if we swap them
  txtAreaData[ta].curs[3] = _marker1;
  
  StandaloneClick.RegisterControl(_bCut, "Cut");
  StandaloneClick.RegisterControl(_bCopy, "Copy");
  StandaloneClick.RegisterControl(_bPaste, "Paste");

}


static void TextAreas::SetScrollbarControls(TEXTAREA ta,  Button* _bUp,  Button* _bDown,  Button* _bElevator)
{
  
  if (_bUp.Y+_bUp.Height >= _bDown.Y) {
    Display("ERROR: Text Areas: Scrollbar 'up' button cannot be displayed lower than the 'down' button. Please adjust your GUI first.");
    return;
  }
  
  txtAreaData[ta].bUp = _bUp;
  txtAreaData[ta].bDown = _bDown;
  txtAreaData[ta].bElevator = _bElevator;


  
  StandaloneClick.RegisterControl(_bUp, "Scroll up");
  StandaloneClick.RegisterControl(_bDown, "Scroll down");
  StandaloneClick.RegisterControl(_bElevator, "Grab and drag to scroll");

  //scrollbar is hidden by default
  txtAreaData[ta].bUp.Visible = false;
  txtAreaData[ta].bDown.Visible = false;
  txtAreaData[ta].bElevator.Visible = false;
  
  txtAreaData[ta].scrollable = true;
  
}


  
static void TextAreas::SetInfoControls(TEXTAREA ta, Label* _lStatus,  Button* _bAbout)
{
  txtAreaData[ta].bAbout = _bAbout;
  
  txtAreaData[ta].statusLine = _lStatus;
  if (_lStatus!=null)
    txtAreaData[ta].statusLine.Text = "";

  StandaloneClick.RegisterControl(_bAbout, "About");
  
}

static void TextAreas::SetSounds(TEXTAREA ta,  AudioClip* typeSound,  AudioClip* warningSound)
{
  txtAreaData[ta].typeSound = typeSound;
  txtAreaData[ta].warningSound = warningSound;
}

  
  